# 05 프로세스 동기화

*<쉽게 배우는 운영체제> pg 287~290*



## 연습문제

1. 

   ```
   반양방향 통신
   ```

2. 

   ```
   바쁜 대기
   ```

3. 

   ```
   대기가 있는 통신: 파이프, 소켓
   대기가 없는 통신: 전역 변수, 파일
   ```

4. 

   ```
   파이프는 단방향 통신이기 때문에 양방향 통신을 하려면 파이프가 2개 필요함
   ```

5. 

   ```
   경쟁조건 발생
   ```

6. 

   ```
   임계구역
   ```

7. 

   ```
   상호배제
   ```

8. 

   ```
   진행의 융통성
   ```

9. 

   ```
   검사와 지정(test-and-set)
   ```

10. 

    ```
    현재 사용 가능한 자원 수
    ```

11. 

    ```
    if RS > 0 then RS = RS - 1;
    else block();
    ```

12. 

    ```
    RS = RS + 1;
    wake_up();
    ```

13. 

    ```
    - 프로세스가 세마포어를 사용하지 않고 바로 임계구역에 들어간 경우, 임계구역을 보호할 수 없음
    - P()를 두 번 사용하여 wake_up()신호가 발생하지 않은 경우, 세마포어 큐에서 대기하고 있는 프로세스들이 무한 대기에 빠짐
    - P()와 V()를 반대로 사용하여 상호 배제가 보장되지 않은 경우, 임계구역을 보호할 수 없음
    ```

14. 

    ```
    검사와 지정
    ```

15. 

    ```
    모니터
    ```

    


## 심화문제

1. 

   ```
   - 양방향 통신: 데이터를 동시에 양쪽으로 전송할 수 있는 구조, ex) 소켓
   - 반양방향 통신: 데이터를 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조, ex) 무전기
   - 단방향 통신: 한쪽 방향으로만 데이터를 전송할 수 있는 구조, ex) 전역 변수, 파이프
   ```

2. 

   ```
   - 대기가 있는 통신: 동기화를 지원하는 통신 방식, 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있음, ex) 파이프, 소켓
   - 대기가 없는 통신: 동기화를 지원하지 않는 통신 방식, 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인, ex) 전역 변수, 파일
   ```
   
3. 

   ```
   - 임계구역은 공유 자원 접근 순서에 따라 실행 순서가 달라지는 프로그램 영역
   - 주방의 믹서기를 사용할 때는 순서를 지켜 작업해야 함, 이미 믹서기를 사용중인 프로세스가 있을 때는 해당 프로세스가 끝날 때까지 기다려야 함
   ```

4. 

   ```
   P1이 while(lock==True); 까지 실행한 순간 타임아웃이 발생해 P2가 실행상태가 되면 P2가 while(lock==True); 를 실행해 임계구역에 진입할 수 있다. 다음에 P1의 차례가 돌아오면 P1도 이미 무한루프 구간을 빠져나왔기 때문에 임계구역에 진입할 수 있다. 결국 상호배제 조건에 맞지 않는다.
   ```
   
5. 

   ```
   상호 배제와 한정 대기는 보장하지만 무조건 서로 번갈아가며 실행되기 때문에 진행의 융통성을 보장하지 못한다.
   ```
   
6. 

   ```c
   # include <studio.h>
   # include <unistd.h>
   # include <fcntl.h>
   
   void main()
   {	int pid, fd;
    	char buf[5];
    
    	fd=open("com.txt", 0_RDWR);
    	pid=fork();
    
    	if(pid<0 || fd<0) exit(-1);
    
    	else if(pid==0) {
           write(fd, "Test", 5);
           close(fd);
           exit(0);	}
    
    	else {	wait(0);
             lseek(fd, 0, SEEK_SET);
             read(fd, buf, 5);
             printf("%s", buf);
             close(fd);
             exit(0);	}
   }
   ```

