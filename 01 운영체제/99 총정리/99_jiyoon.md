# 99 총정리

***운영체제 면접 대비***

## 1. 운영체제의 개요

1. 운영체제란 무엇인가요?

   ```
   사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어
   ```

2. 운영체제의 주요 목적은 무엇인가요?

   ```
   자원 관리를 통한 효율성, 자원 보호를 통한 안정성, 하드웨어 인터페이스 제공을 통한 확장성, 사용자 인터페이스 제공을 통한 편리성
   ```


## 2. 컴퓨터의 구조와 성능 향상

1. 버퍼와 스풀의 차이점은 무엇인가요?

   ```
   + 버퍼, 스풀 정의 1줄씩
   버퍼는 프로그램 간 버퍼를 공유하지만, 스풀은 CPU와 입출력장치가 독립적으로 동작하도록 고안되었기 때문에 프로그램 간 배타적이라고 할 수 있다. (스풀의 대표적인 예시인 프린터의 스풀러는 한 작업의 인쇄가 완료되기 전까지 다른 작업이 끼어들 수 없음)
   ```

2. 캐시의 지역성에 대해 설명하시오.

   ```
   캐시는 '메모리의 데이터를 미리 가져와 저장해두는 임시 장소'인데, 이때 미리 가져올 데이터를 정함에 있어서 현재 위치에 가까운 데이터가 멀리 있는 데이터가 사용될 확률이 높다는 것을 뜻한다.
   + 시간적 지역성, 공간적 지역성
   ```
   
3. 직접 메모리 접근(DMA)이란? CPU와 DMA가 동시에 메모리에 접근한다면?

   ```
   원래는 CPU만 메모리에 접근할 수 있었으나, 데이터의 입출력이 이루어지는 동안 CPU가 다른 작업을 할 수 있게 인터럽트 방식을 사용하여 입출력 관리자가 데이터를 옮길 수 있게 되었음. 이때 입출력 관리자가 직접 메모리에 접근할 수 있도록 주어진 권한을 직접 메모리 접근(DMA)이라고 한다.
   CPU와 DMA가 동시에 메모리에 접근한다면 보통은 CPU가 DMA에 순서를 양보하며, 이를 사이클 훔치기라고 한다.
   ```

## 3. 프로세스와 스레드

1. 프로세스와 스레드의 차이는 무엇인가요? (N사)

   ```
   프로세스가 컴퓨터 시스템의 작업 단위(운영체제로부터 자원을 할당받는 작업 단위)라면, 스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 프로세스가 요리 작업 전체라면 스레드는 요리를 완성하기 위해 수행하는 각각의 조리과정이라 할 수 있다.
   ```
   
2. PCB는 무엇인가요?

   ```
   프로세스 제어 블록(Process Control Block)은 운영체제가 해당 프로세스를 위해 관리하는 자료 구조로, 일종의 작업 지시서이다. PCB에는 프로세스 구분자, 메모리 관련 정보, 각종 중간값들이 들어 있다. 프로세스 생성 시 만들어지고, 프로세스가 완료되면 폐기된다.
   ```

3. 멀티스레드와 멀티 프로세스 환경이 자원공유 관점에서 어떻게 다른가? (K사)

   ```
   멀티스레드는 프로세스 내에서 메모리를 공유하고, 멀티프로세스는 각각 별개의 메모리를 차지한다. 따라서 멀티프로세스는 한 프로세스에 문제가 발생해도 다른 프로세스로 전달되지 않지만, 멀티스레드의 경우 전체 프로세스에 영향을 미친다.
   (IPC 추가적으로 찾아보기)
   ```

4. 멀티스레드의 장점과 단점은 무엇인가요?

   ```
   멀티스레드는 자원 공유를 통해 작업을 원활하게 진행할 수 있고, 불필요한 자원의 중복을 막음으로써 시스템 효율을 향상시킨다. 또한 다중 CPU 지원을 통해 프로세스의 처리 시간을 단축시켜 사용자의 작업 요구에 빠르게 응답할 수 있다는 장점이 있다. 그러나 한 스레드에 문제가 발생할 경우(동기화 문제) 전체 프로세스에 영향을 주어 다른 스레드의 작업도 중단될 우려가 있다.
   ```

5. 멀티스레스와 멀티프로세스의 차이점을 말하시오.

   ```
   멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥교환이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있다. 반면 멀티 프로세스는 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있다.
   ```

6. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇입니까?

   ```
   프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있고, 스레드 간의 통신 비용이 적어 통신 부담이 줄어들기 때문이다.
   ```

7. 문맥 교환(Context Switching) 이란?

   ```
   문맥 교환은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다. 문맥 교환이 일어나면 PCB 교체와 동시에 작업 환경을 바꾸어야 한다. 실행 상태에서 나가는 PCB에는 지금까지 작업한 내용을 저장하고, 실행 상태로 들어오는 PCB의 내용을 CPU가 다시 세팅한다.
   ```

8. 사용자 스레드와 커널 스레드의 차이는?

   ```
   커널 스레드는 OS에서 구현되고, 사용자 스레드는 스레드 기능을 제공하는 라이브러리를 활용하여 수행되기 때문에 커널에 직접 진입하지 않고 사용자 영역에서 스레드 연산을 수행한다. 동일한 메모리 영역에서 스레드가 생성, 관리되므로 스케줄링과 동기화가 필요한 커널 스레드에 비해 속도가 빠르다. (보안 취약, 멀티 CPU 사용 여부 추가할 것)
   ```

## 4. CPU 스케줄링

1. CPU 스케줄링을 사용하는 목적을 말해보세요.

   ```
   공평성, 효율성, 안정성, 확장성, 반응 시간 보장, 무한 연기 방지
   (각 목적별로 완전히 외우고 이해하기)
   ```

2. CPU 스케줄링은 언제 발생하는가?

   ```
   (다시 정리해보기)
   프로세스에 CPU를 할당하고자 할 때
   - 프로세스가 실행 상태에서 대기 상태로 전환될 때
   - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
   - 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때
   - 프로세스가 종료할 때
   ```

3. 선점 스케줄링과 비선점 스케줄링에 대해 설명해보세요.

   ```
   선점형 스케줄링은 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식이고, 비선점형 스케줄링은 다른 프로세스가 이미 실행중인 프로세스의 턴을 빼앗을 수 없는 방식이다. 과거 일괄 작업 시스템 시절에는 비선점형 스케줄링이 주로 사용되었으나 현재는 빠른 응답 시간과 높은 시스템 처리율을 가진 선점형 스케줄링이 사용된다.
   ```

4. 아사(기아) 현상이란?

   ```
   실행시간이 짧은 프로세스를 선점 우선순위로 두었을 때, 실행시간이 긴 프로세스의 작업이 지속적으로 연기되는 현상을 말한다. 에이징으로 완화 가능하다.
   ```

5. 에이징이란?

   ```
   아사 현상이 발생했을 때 이를 완화할 수 있는 방법으로 프로세스가 양보할 수 있는 상한선을 정하는 방식이다. 하지만 에이징 값을 정하는 기준이 애매하여 실제로 활용하기에는 한계가 있다.
   ```

6. 라운드 로빈 스케줄링을 설명해보세요.

   ```
   순환 순서 방식이라고도 하는 라운드 로빈 스케줄링은 한 프로세스가 할당받은 시간동안 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 다시 자기 차례를 기다리는 선점형 알고리즘 방식이다. 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행된다. (+타임 슬라이스 설정 관련)
   ```

7. FCFS 스케줄링을 설명해보세요.

   ```
   선입선출 스케줄링이라고도 하는 FCFS 스케줄링은 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 스케줄링 방식이다. 초기의 일괄 작업 시스템에서 주로 사용되었다.
   ```

8. SJF 스케줄링을 설명해보세요.

   ```
   최단 작업 우선 스케줄링은 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식이다. FCFS 스케줄링의 콘보이 효과를 완화하였지만 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵고 공평하지 않다는 단점 때문에 잘 사용되지 않는다.
   ```

9. SRTF 스케줄링을 설명해보세요.

   ```
   최소 잔류 시간 우선 스케줄링인 SRT(F)는 SJF와 로빈 스케줄링 방식을 합친 것이다. 프로세스 실행 중 더 적은 작업 시간을 요구하는 프로세스가 들어오면 해당 프로세스를 실행한다. 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이 적은 프로세스와 문맥 교환을 해야 하므로 SJF 스케줄링에는 없는 작업이 추가되며 운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어날 수 있다.
   ```

## 5. 프로세스 동기화

1. 임계구역은 무엇인가요?

   ```
   공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역으로, 둘 이상의 프로세스가 동시에 접근해서는 안 되는 코드의 일부를 말한다. 따라서 어떤 프로세스가 이미 선점된 임계구역에 들어가고자 한다면 대기가 필요하다.
   ```

2. 임계구역의 문제를 해결할 수 있는 조건은 무엇인가요?

   ```
   상호 배제, 한정 대기, 진행의 융통성
   한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없고, 특정 프로세스가 지속적으로 임계구역에 진입하지 못하면 안 되고, 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.
   ```

3. 동기와 비동기의 차이는 무엇인가요?

   ```
   [동기(Sync)]
   - 메소드를 실행시킴과 동시에 반환값이 기대되는 경우
   - 값이 반환되기 전까지 다음 프로세스가 blocking됨
   
   [비동기(Async)]
   - 메소드를 실행시킴과 동시에 반환값이 기대되지 않는 경우
   - 값이 반환되기 전까지 다음 프로세스가 blocking 되지 않고 실행됨
   
   -------- (위에걸로 다시 답변 써보기)
   
   동기(화를 지원하는 통신)는 데이터를 받는 쪽에서 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있고, 비동기는 데이터를 받는 쪽이 바쁜 대기를 사용하여 데이터가 도착했는지를 직접 확인해야 한다.
   ```

4. 임계구역의 해결방법을 말해보세요.

   ```
   1. 임계구역 해결 조건을 고려한 코드설계
   2. 피터슨 알고리즘
   3. 데커 알고리즘
   4. 세마포어 알고리즘
   5. 모니터
   ```

5. 세마포어란?

   ```
   임계구역 해결 방법 중 하나로, 임계구역에서 나온 프로세스가 동기화 신호를 활용하여 기다리는 프로세스에 신호를 준다. 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 큐에서 나와 임계구역에 진입한다. 공유 자원이 여러 개일 때도 사용 가능하다.
   (수정: 가용한 개수를 가진 자원에 대해 접근 제어용으로 사용되고, 세마포어는 그 가용한 자원의 개수로 초기화됨
   모든 프로세스/스레드가 확인할 수 있도록 빈자리의 수를 표시하고, 프로세스/스레드는 세마포어를 확인하고 빈자리가 있다면 자원에 접근하고 자원 사용 전/후로 세마 포어를 수정해 줌)
   ```

6. 세마포어와 뮤텍스의 차이는?

   ```
   세마포어는 공유된 자원에 여러 프로세스가 접근하는 것을 막는 방식이고, 뮤텍스는 여러 스레드가 접근하는 것을 막는 방식이다. 세마포어에는 세마포어에 선언된 변수만큼의 프로세스가 접근할 수 있으나, 뮤텍스에는 오직 1개만 접근할 수 있다. 세마포어의 경우 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있으나, 뮤텍스는 반드시 락을 획득한 프로세스가 그 락을 해제해야 한다.
   ```

## 6. 교착 상태

1. 교착 상태란 무엇인가요?

   ```
   2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 진행하지 못하는 상태
   ```

2. 교착 상태의 발생 조건에 대해 말해보세요.

   ```
   상호배제, 비선점, 점유와 대기, 원형 대기를 모두 충족할 때 교착 상태가 발생한다. 자원이 공유 불가능한 배타적인 자원인 경우, 한 프로세스가 사용중인 자원을 빼앗을 수 없는 경우, 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 경우, 점유와 대기 상태에 있는 프로세스들의 관계가 원을 이루는 경우로 풀이될 수 있다.
   ```

3. 교착 상태의 해결 방법을 말하시오.

   ```
   예방, 회피, 검출, 회복
   예방은 교착 상태를 유발하는 네 가지 조건을 무력화하는 방법, 회피는 교착 상태가 발생하지 않는 수준으로 자원을 할당하는 방법, 검출은 자원 할당 그래프를 통해 교착 상태를 발견하는 방법, 회복은 검출된 교착 상태를 해결하는 것이다. 현실적으로는 검출-회복이 해결 방법으로 쓰인다.
   ```

4. Banker's algorithm은 무엇입니까?

   ```
   교착 상태 회피 방법 중 하나로 대출 금액이 대출 가능한 범위 내이면 허용되지만 그렇지 않으면 거부되는 것과 유사하기 때문에 붙여진 이름이다. 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당하고, 가용 자원이 어떤 기대 자원보다도 크지 않으면 할당하지 않는 방식이다.
   ```

5. 상호배제란?

   ```
   한 프로세스가 사용하는 자원을 다른 프로세스와 공유할 수 없는 경우, 배타적인 자원은 임계구역으로 보호된다.
   ```

## 7. 물리 메모리 관리

1. 외부 단편화와 내부 단편화를 비교해보세요.

   ```
   KEYWORD: 내부-고정, 외부-가변
   
   내부 단편화는 고정 분할 방식으로 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 프로세스에서 사용하는 메모리 공간이 낭비되는 현상이다. 반면 외부 단편화는 가변 분할 방식으로 메모리의 할당 및 해제 작업의 반복되며 사용하지 않는 메모리가 중간중간 존재하게 되어 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황을 말한다.
   ```

2. 컴파일러와 인터프리터의 차이점은 무엇인가요? (N사)

   ```
   KEYWORD: 소스코드, 기계어 번역
   
   컴파일러는 소스코드를 전체 기계어로 번역한 후 한꺼번에 실행하고, 이 과정에서 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다.
   인터프리터는 소스코드를 한 행씩 번역하여 실행하기 때문에 같은 일을 반복하는 경우나 쓰이지 않는 변수를 확인할 수 없다.
   따라서 크고 복잡한 프로그램은 컴파일러, 간단한 프로그램은 인터프리터를 사용하는 것이 좋다.
   ```

3. 메모리 구조는 어떻게 구성되어 있나? (K사)

   ```
   KEYWORDS: 코드, 데이터, 스택, 힙
   
   메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 구성된다.
   코드 영역은 실행할 프로그램의 코드가 저장되는 영역으로, CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다. 데이터 영역에는 프로그램의 전역 변수와 정적 변수가 저장되며, 스택 영역에는 함수의 호출과 관계되는 지역 변수와 매개변수가 저장된다. 힙 영역은 사용자가 직접 관리하는 메모리 영역이다.
   ```

4. 스왑이 무엇이고 이를 통한 이점은? (K사)

   ```
   스왑은 메모리가 모자라서 쫓겨난 프로세스를 모아두는 저장장치의 특별한 공간이다. 스왑을 이용하면 스왑 영역의 크기가 메모리의 크기로 인식되기 때문에 실제 메모리 크기보다 큰 프로그램을 저장하고 실행시킬 수 있다. (확인필요)
   ```

5. 메모리 관리의 배경에 대해 말해보세요.

   ```
   KEYWORDS: 효율성
   
   각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없다. 오직 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역에 모두 접근할 수 있기 때문에 운영체제에서 메모리를 효율적으로 관리해야 한다.
   ```

6. 페이징과 세그먼테이션 기법의 차이점을 설명해 보세요.

   ```
   KEYWORDS: 고정 분할/가변 분할
   
   가상 메모리는 고정 분할 방식을 통해 페이지라는 블록으로 나누어지고, 가변 분할 방식을 통해서는 서로 다른 크기의 세그먼트로 나뉘어진다. 페이지는 고정적인 데이터이며 시스템에 의해 할당받는 물리적 단위이지만, 세그먼트는 사용자 관점의 분할이다.
   ```

7. 논리적 주소와 물리적 주소의 차이를 설명하시오.

   ```
   KEYWORDS: 사용자/하드웨어
   
   논리 주소는 사용자 입장에서 바라본 주소이고 CPU가 생성한 가상의 주소를 말한다. 반면 물리 주소는 하드웨어 입장에서 바라본 주소로 컴퓨터에 꽂힌 렘 메모리의 실제 주소이다.
   ```

8. 메모리 오버레이에 대해 알려주세요.

   ```
   KEYWORDS: 실제 메모리, PC
   
   프로그램의 크기가 실제 메모리보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 방법이다. 실행하는 데 필요한 중요한 모듈만 올려놓고 나머지는 필요할 때마다 메모리에 가져와 사용한다. PC(프로그램 카운터)가 떤 모듈을 가져오거나 내보낼지 결정한다. 
   ```
   

## 8. 가상 메모리의 기초

1. 가상 메모리란 무엇인가요?

   ```
   KEYWORDS: 메모리 공간 제공
   
   크기가 다른 물리 메모리에서 알관되게 프로세스를 실행할 수 있도록 물리 메모리의 크기와 상관없이 프로세스에 큰 메모리 공간을 제공하는 기술이다. 이론적으로는 무한대의 크기를 가지나 실제 크기는 물리 메모리와 스왑 영역의 합이라고 볼 수 있다.
   ```

2. 페이징은 무엇인가요?

   ```
   KEYWORDS: 고정 분할, 페이지-프레임
   
   페이징은 고정 분할 방식을 이용한 가상 메모리 관리 기법이다. 가상 주소의 분할된 영역을 페이지라 부르고, 물리 주소의 분할된 영역은 프레임이라고 부른다. 이때 페이지와 프레임은 크기가 같아서 페이지는 어떤 프레임에도 배치될 수 있다.
   ```

3. 가상 메모리의 역할은 무엇인가요?

   ```
   1번과 중복?
   ```

4. 세그먼테이션 기법이란 무엇인가요?

   ```
   KEYWORDS: 가변 분할
   
   세그먼테이션 기법은 가변 분할 방식을 이용한 가상 메모리 관리 기법이다.
   ```

5. 가상 주소 공간에 대해 설명하세요.

   ```
   KEYWORDS: 프로세스 입장, 0번
   
   가상 주소 공간은 프로세스 입장에서 바라본 메모리 공간으로, 프로세스가 사용할 수 있는 가상 주소들의 집합이다. 각 프로세스는 자신만의 독립적인 주소 공간을 가지며, 항상 0번부터 시작한다.
   ```

## 9. 가상 메모리 관리

1. 요구 페이징은 무엇인가요?

   ```
   KEYWORDS: 효율성, 응답 속도 향상
   
   요구 페이징은 프로세스가 필요로 하는 데이터를 메모리에 가져오는 방법이다. 용량이 큰 프로세스를 실행할 때 메모리를 효율적으로 관리하고 응답 속도를 향상시키기 위해 프로세스의 일부만 메모리로 가져오는데, 이처럼 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것을 요구 페이징이라 한다.
   ```

2. 페이징 부재(페이지 폴트)는 무엇인지 설명해보세요.

   ```
   KEYWORDS: 스왑 영역
   
   페이지 부재는 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 말한다. 페이지 부재가 발생하면 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 한다.
   ```

3. 페이지 교체 알고리즘 중 LRU에 대해서 설명해 보세요. (N사)

   ```
   KEYWORDS: 카운터, 참조 비트
   
   Least Recently Used 페이지 교체 알고리즘은 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다. 이때 시간을 기준으로 구현하거나, 카운터나 참조 비트를 이용하는 방식이 있다.
   ```

4. 페이지 교체 알고리즘 중 FIFO에 대해서 설명해 보세요.

   ```
   KEYWORDS: 시간의 지역성
   
   First In First Out 페이지 교체 알고리즘은 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정한다. 시간의 지역성을 고려했으나 메모리에 올라온 지 오래되었더라도 자주 사용되는 페이지를 고려하진 못한 방법이다.
   ```

5. 페이지 교체 알고리즘 중 LFU에 대해서 설명해 보세요.

   ```
   KEYWORDS: 사용 횟수
   
   Least Frequently Used 페이지 교체 알고리즘은 현재 프레임에 있는 페이지마다 그동안 사용된 횟수를 세어, 횟수가 가장 적은 페이지를 스왑 영역으로 옮긴다. 사용 빈도가 같은 페이지가 여러 개 있을 때는 맨 처음에 있는 페이지가 쫓겨난다.
   ```

6. 페이지 교체 알고리즘 중 MFU에 대해서 설명해 보세요.

   ```
   KEYWORDS: 사용(참조) 횟수
   
   Most Frequently Used 페이지 교체 알고리즘은 LFU와 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다. 참조 횟수가 적은 페이지가 최근에 사용된 것이기 때문에 앞으로 사용될 가능성이 높다는 판단이다.
   ```

## 10. 입출력 시스템과 저장장치

1. RAID란 무엇인가요?

   ```
   KEYWORDS: 백업, 복구
   
   자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템으로, 값싼 디스크 여러 개를 모아 구성한다. 원리는 하나의 원본 디스크와 같은 크기의 백업 디스크에 같은 내용을 동시에 저장하고, 하나의 디스크가 고장났을 때 다른 디스크를 사용하여 데이터를 복구하는 것이다. 
   ```

2. 디스크 스케줄링 기법이란 무엇이며, 한 가지 스케줄링 기법과 함께 설명하시오.

   ```
   KEYWORDS: 트랙 이동 최소화, 탐색 시간
   
   디스크 스케줄링이란 트랙의 이동을 최소화하여 데이터 전송 시간 중 탐색 시간을 줄이는 스케줄링 기법이다. 한 가지 예로 SCAN 디스크 스케줄링이 있는데, 이는 헤드가 한 방향으로만 움직이면서 맨 마지막 트랙에 도착할 때까지 앞으로만 전진하며 서비스하는 스케줄링 방식이다. 마지막 트랙에 도착하면 방향을 바꾼다. 바깥 쪽 트랙이 아사 현상을 겪을 수 있고 공평성을 위배하지만 많이 사용되는 스케줄링 방식이다.
   ```

3. 인터럽트란?

   ```
   KEYWORDS: 외부 인터럽트, 내부 인터럽트, 시그널
   
   인터럽트는 주변장치의 입출력 요구나 하드웨어의 이상 현상을 CPU에 알려주는 역할을 하는 신호이다. 하드웨어의 오류로 발생하는 외부 인터럽트와 프로세스의 잘못이나 예외 상황 때문에 발생하는 내부 인터럽트, 사용자가 직접 발생시키는 시그널(자발적 인터럽트)로 구분된다.
   ```

## 11. 파일 시스템

1. 순차 파일 구조에 대해 설명해보세요.

   ```
   KEYWORDS: 카세트테이프
   
   파일 내용이 하나의 긴 줄로 늘어선 형태로, open()이나 create() 명령어로 운영체제로부터 이용 권한을 얻고, read(), write() 명령어로 읽기와 쓰기를 수행하고, lseek() 명령으로 파일 디스크립트를 옮기는 구조로 되어 있다.
   ```

2. 디스크 할당 방식 중 연속 할당과 불연속 할당에 대해 설명하시오.

   ```
   KEYWORDS: 블록 연결, 파일 시스템
   
   일반적으로 하나의 파일은 여러 개의 블록에 저장되는데, 이것들을 어떻게 연결하는지에 따라 연속 할당과 불연속 할당 방식으로 구분된다. 연속 할당은 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식으로, 파일의 시작 블록만 알면 전체 파일을 찾을 수 있다. 불연속할당은 비어있는 블록에 데이터를 분산하여 저장하고, 이에 관한 정보를 파일 시스템이 관리하는 방식이다.
   ```

## 12. 네트워크와 분산 시스템

1. 클라이언트/서버 시스템의 구조를 설명해 보세요.

   ```
   KEYWORDS: 이중 구조, 웹 브라우저, HTTP, HTML
   
   클라이언트/서버 시스템은 작업을 요청하는 클라이언트와 요청받은 작업을 처리하는 서버의 이중 구조로 되어 있다. 클라이언트가 서버에 작업을 요청하고 그 결과물을 받는 과정은 다음과 같다. 먼저 클라이언트가 웹 브라우저에 서버 주소를 입력하고, 웹 브라우저는 HTTP를 이용하여 서버에 있는 HTML을 요청한다. 서버는 클라이언트의 요청을 처리한 후 결과를 클라이언트에 전달한다. 결과가 클라이언트에 도착하면 웹 브라우저가 그 내용을 화면에 출력한다.
   ```

2. 고가용성이란 무엇인가요?

   ```
   KEYWORDS: 클라이언트/서버 시스템, 이중화
   
   클라이언트/서버 시스템에서 중앙 서버가 고장나 전체 서비스가 중단되는 것을 막기 위해 이중화 작업을 하는 것
   ```

   
