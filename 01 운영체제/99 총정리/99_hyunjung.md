# 99 총정리

*<쉽게 배우는 운영체제>* 



## 1. 운영체제의 개요

1. 운영체제란 무엇인가요?

   ```
   - OS(Operating System)이라고 일컫는 '운영체제'는 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어
   - 예시 : 개인용 컴퓨터의 Windows, Mac OS, 리눅스, 대형 컴퓨터의 유닉스, 리눅스, 윈도우 서버, 스마트폰의 애플의 IOS, 구글의 안드로이드 등 다양한 기기에서 사용되어지고 있음
   ```

2. 운영체제의 주요 목적은 무엇인가요?

   ```
   - 자원 관리 : 자원을 응용프로그램에 나누어주어 사용자가 원활하게 작업할 수 있도록 도움
   - 자원 보호 : 비정상적인 작업(악의적인, 미숙한 사용자)으로부터 컴퓨터 자원을 보호
   - 하드웨어 인터페이스 제공 : 복잡한 과정 없이 다양한 장치를 사용할 수 있도록 해주는 하드웨어 인터페이스 제공
   - 사용자 인터페이스 제공 : 사용자가 운영체제를 편리하게 사용하도록 지원하기 위함(GUI)
   
   + 정리 : 자원 관리를 통한 효율성, 자원 보호를 통한 안정성, 하드웨어 인터페이스 제공을 통한 확장성, 사용자 인터페이스 제공을 통한 편리성
   ```
   
   


## 2. 컴퓨터의 구조와 성능 향상

1. 버퍼와 스풀의 차이점은 무엇인가요?

   ```
   - 버퍼 : 속도 차이가 있는 두 장치에서 그 차이를 완화하는 역할(입출력장치, 메모리, 소프트웨어 모두 가능)
   - 스풀 : CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼
   - 차이점 : 버퍼의 경우 어떤 프로그램이 사용하는 데이터든 버퍼가 차면 이동이 시작된다.(프로그램들이 버퍼를 공유한다.) 반면에 스풀은 프로그램간에 배타적이다. 
   ```

2. 캐시의 지역성에 대해 설명하시오.

   ```
   - 현재 위치에 가까운 데이터가 멀리 있는 데이터보다 사용될 확률이 높다는 것
   
   + 시간적 지역성 : 한번 접근한 데이터는 가까운 미래에 다시 사용될 수 있음
   + 공간적 지역성 : 접근한 데이터의 주위 데이터가 가까운 미래에 사용될 수 있음
   ```

3. 직접 메모리 접근(DMA)이란? CPU와 DMA가 동시에 메모리에 접근한다면?

   ```
   - 입출력이 필요하면 CPU는 입출력 관리자에게 요청을 보내고 할 일을 함 -> 입출력 관리자는 CPU가 요청한 데이터를 메모리에 가져다 놓아야 하는데 메모리는 CPU만 접근 권한을 가져서 입출력 관리자는 접근이 불가함
   - 따라서 입출력 관리자에게 CPU의 허락 없이 메모리에 접근할 수 있는 권한을 주는 것이 **직접 메모리 접근**
   - 만약 CPU와 DMA가 동시에 메모리에 접근한다면 보통 CPU가 메모리 사용 권한을 양보함 : CPU의 작업 속도보다 입출력장치의 속도가 느리기 때문에 양보한다. -> **사이클(순서) 훔치기** 라고 부른다.
   ```



## 3. 프로세스와 스레드

1. 프로세스와 스레드의 차이는 무엇인가요?(N사) (P.165~166)

   ```
   - 프로세스 : 프로그램의 실행을 위해 메모리에 올라온 동적 상태 (누군가가 작성한 프로그램이 실행되면 프로세스가 된다!), 서로 독립적이다.
   - 스레드 : 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위, 서로 강하게 연결되어 있다.
   - 예시 : 안심 스테이크(프로세스) = 레시피 + 고기굽기 + 채소굽기 + 소스뿌리기 등의 조리(스레드)
   ```

2. PCB가 무엇인가요? (P.146)

   ```
   - 프로세스 제어 블록(Process Control Block) : 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조
   
   + PCB에는 프로세스 구분자, 메모리 관련 정보, 각종 중간값들이 들어 있다. 프로세스 생성 시 만들어지고, 프로세스가 완료되면 폐기된다.
   ```

3. 멀티스레드와 멀티 프로세스 환경이 자원공유 관점에서 어떻게 다른가?? (카카오 본사 기출) ✅

   ```
   * 멀티 프로세스(=멀티태스크)
   + 멀티스레드는 프로세스 내에서 메모리를 공유하고, 멀티프로세스는 각각 별개의 메모리를 차지한다. 따라서 멀티프로세스는 한 프로세스에 문제가 발생해도 다른 프로세스로 전달되지 않지만, 멀티스레드의 경우 전체 프로세스에 영향을 미친다.
   + 뮤텍스, 세마포어
   ```
   
4. 멀티스레드 장점과 단점은 무엇인가요?

   ```
   <장점> 
   - 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다.
   - 자원 공유 : 한 프로세스 내에서 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행할 수 있다.
   - 효율성 향상 : 여러 개의 프로세스를 생성하는 것과 달리 멀티스레드는 불필요한 자원의 중복을 막음으로써 시스템의 효율이 향상된다.
   - 다중 CPU 지원 : 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 다중 CPU가 멀티 스레드를 동시에 처리하여 CPU 사용량이 증가하고 프로세스의 처리 시간이 단축된다.
   
   <단점>
   - 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.
   ```

5. 멀티스레드와 멀티프로세스의 차이점을 말하시오.

   ```
   <멀티 스레드>
   - 스레드들은 강하게 연결되어 있음(의존적), 프로세스 내의 메모리를 공유함, 전역 변수나 함수 호출 등의 방법으로 스레드 간 통신을 한다. ex) 워드프로세서 내 문서 편집, 문서 입출력, 맞춤법 검사, 그림판 등
   <멀티 프로세스>
   - CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경(독립적), IPC(프로세스 간 통신)을 활용, ex) 워드프로세서, 프린터 스풀러 등
   ```

6. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇입니까? 

   ```
   - 쉽게 말하면 프로그램을 여러 개 켜는 것보다 하나의 프로그램 안에서 여러 작업을 처리할 수 있기 때문
   - 자원의 효율성 증대 : 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
   - 처리 비용 감소 및 응답 시간 단축 : 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신 부담이 줄어든다. 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
   ```

7. 문맥 교환(Context Switching) 이란?(P.149~150)

   ```
   - CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아 들이는 작업
   - PCB 교체와 동시에 작업환경을 바꾸는 것
   - 절차 : 실행 상태에 있는 프로세스가 자신에게 주어진 시간을 다 사용하여 타임아웃이 되면 해당 프로세스 제어블록에 현재까지 작업결과가 저장되고 준비 상태로 쫓겨난다. 준비상태에 있던 다음 프로세스가 실행 상태로 가면 CPU의 레지스터가 프로세스 제어 블록 값으로 채워져 다음 작업을 실시함
   ```

8. 사용자 스레드와 커널 스레드의 차이는? 

   ```
   <사용자 스레드>
   - 라이브러리에 의해 구현된 일반적인 스레드
   - 문맥 교환이 필요 없어서 속도가 빠름
   - 여러 개의 CPU를 동시에 사용할 수 없음
   - 라이브러리에서 공유 변수 보호 장치를 구현해야되기 때문에 보안에 약함
   - 라이브러리로 커널이 지원하는 스케쥴
   
   <커널 스레드>
   - 커널이 직접 생성하고 관리하는 스레드
   - 문맥 교환이 필요해 오버헤드로 속도가 느림
   - 멀티 CPU 사용 가능
   - 보안에 강하고 안정적임
   
   + 라이브러리 사용 / 커널 사용인 것, 멀티 CPU 사용 불가능 / 가능, 문맥 교환 O / X
   ```



## 4. CPU 스케줄링

1. CPU 스케줄링을 사용하는 목적을 말해보세요.

   ```
   - 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야하고, 자원 배정에 있어 특정 프로세스가 배제되어서는 안 된다.
   - 효율성 : 시스템 자원이 유휴시간 없이 사용되도록 스케줄링, 유휴자원을 사용하려는 프로세스에 우선권을 주어야 한다.
   - 안정성 : 우선 순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유/파괴하려는 프로세스로부터 자원을 보호해야 한다.
   - 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 한다.
   - 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
   - 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.
   
   + 공평성, 효율성, 안정성, 확장성, 반응 시간 보장, 무한 연기 방지를 위해서 사용합니다.
   ```

2. CPU 스케줄링은 언제 발생하는가?

   ```
   - 프로세스가 실행 상태에서 대기 상태로 전환될 때
   - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
   - 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때
   - 프로세스가 종료할 때
   
   + 고수준, 중간수준, 저수준
   ```

3. 선점 스케줄링과 비선점 스케줄링을 간단하게 설명해보세요.

   ```
   - 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
   - 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
   
   + 과거 일괄 작업 시스템 시절에는 비선점형을 사용, 현재는 선점형 스케줄링을 사용
   ```

4. 아사(기아) 현상이란?

   ```
   - 실행 시간이 짧은 작업으로 인해 특정 작업이 계속 연기되는 현상(=무한 봉쇄 현상)
   
   + 에이징으로 완화 가능
   ```

5. 에이징이란?

   ```
   - 프로세스가 양보할 수 있는 상한선을 정하는 방식
   - 에이징 값을 어떤 기준으로 정할지가 문제라 한계가 있음
   
   + 아사 현상이 발생할 때 이를 완화할 수 있는 방법
   ```

6. 라운드 로빈 스케줄링을 설명해보세요.

   ```
   - 한 프로세스가 할당받은 시간동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
   - FCFS 스케줄링과 유사하지만 각 프로세스마다 CPU를 사용할 수 있는 최대 시간, 즉 타임슬라이스가 있다는 것 -> 효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스를 적절히 설정해야 한다.(시스템 전체의 성능에도 영향을 미침)
   ```

7. FCFS 스케줄링을 설명해보세요.

   ```
   * FCFS 스케줄링 = 선입선출 스케줄링
   - 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
   - 단순하고 공평하지만, 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어지는 문제(콘보이 효과 또는 호위 효과)가 있다.
   ```

8. SJF 스케줄링을 설명해보세요.

   ```
   - SJF 스케줄링 = 최단 작업 우선 스케줄링
   - 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
   - FCFS 스케줄링의 콘보이 효과를 완화하고 평균 대기 시간이 줄어들어 시스템 효율성은 높아지지만, 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵고 공평하지 않은 단점이 있다.
   ```

9. SRT(F) 스케줄링을 설명해보세요. (= SJF랑 비슷)

   ```
   - SRT 스케줄링 = 최소 잔류 시간 우선 스케줄링
   - SJF 스케줄링 + 라운드 로빈 스케줄링
   - 평균 대기 시간이 짧지만 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고 남은 시간이 더 적은 프로세스와 문맥 교환을 해야하므로 SJF 스케줄링에는 없는 작업이 추가 됨
   - 운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어날 수 있음
   - 따라서 좋은 알고리즘이 아니다.
   ```



## 5. 프로세스 동기화

1. 임계구역은 무엇인가요? 

   ```
   - 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역 (각 프로세스가 전역 변수(예금)을 저장하는 부분)
   ```

2. 임계구역에 문제를 해결할 수 있는 조건은 무엇인가요? 

   ```
   - 상호 배제 : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다.
   - 한정 대기 : 특정 프로세스가 임계구역에 지속적으로 진입하지 못하면 안 된다.
   - 진행의 융통성 : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.
   ```

3. 동기와 비동기의 차이는 무엇인가요? (모르겠습니다...)

   ```
   - 동기 : 요청과 그 결과가 동시에 일어남
   - 비동기 : 요청과 결과가 동시에 일어나지 않음
   
   + 동기(Sync) : 메소드를 실행시킴과 동시에 반환값이 기대되는 경우, 값이 반환되기 전까지 다음 프로세스가 blocking됨
   + 비동기(Async) : 메소드를 실행시킴과 동시에 반환값이 기대되지 않는 경우, 값이 반환되기 전까지 다음 프로세스가 blocking 되지 않고 실행됨
   ```

4. 임계구역의 해결방법을 말해보세요. 

   ```
   <임계구역 해결 조건을 고려한 코드 설계>
   - 단순한 방법은 잠금을 이용하는 것
   - boolean 변수는 true와 false 값만 가질 수 있으므로 잠금을 표현하기에 적합
   - 상호 배제 문제 : 임계구역에 잠금이 걸려있는지 확인(lock==true;)한 후 잠겨 있으면 잠금이 해제될 때까지 무한 루프를 돌면서 기다린다(while(lock==true);). 작업을 해제하면 다른 프로세스는 진입하지 못하도록 잠금을 걸고 작업을 실행한다.
   - 한정 대기 문제 : 임계구역에 잠금이 걸려 있는지 확인한 후 잠금(lock1==true;)을 건다. 다른 프로세스가 잠금을 설정했는지 확인(while(lock2==true);)한다. 잠금을 설정하지 않았다면 임계구역에 진입하여 작업을 마친 후 잠금을 해제(lock1==false;)한다.
   - 진행의 융통성 : 공유 변수 lock의 값을 통해 다른 프로세스가 임계구역에 있는지 확인하고 없으면 진입한다. 해당 프로세스는 while(lock==2);문을 실행하고 다른 프로세스가 잠금을 걸었으면 기다린다. lock==1이면 해당 프로세스가 임계구역에 진입하고, 임계구역을 빠져나올 때 lock을 2로 바꾼다.
   
   + 임계구역 해결 조건을 고려한 코드 설계, 피터슨 알고리즘, 데커 알고리즘, 세미포어 알고리즘, 모니터
   ```

5. 세마포어란 무엇입니까?

   ```
   - 공유된 자원의 데이터 혹은 임계구역 등에 여러 프로세스 혹은 스레드가 접근하는 것을 막아줌
   ```

6. 세마포어 vs 뮤텍스 차이

   ```
   - 세마포어 : 공유된 자원의 데이터 혹은 임계구역 등에 여러 프로세스 혹은 스레드가 접근하는 것을 막아줌 (즉, 동기화 대상이 하나 이상)
   - 뮤텍스(=상호 배제) : 공유된 자원의 데이터 혹은 임계구역 등에 하나의 프로세스 혹은 스레드가 접근하는 것을 막아줌(즉, 동기화 대상이 하나)
   
   + 세마포어는 현재 수행중인 프로세스가 아닌 다른 프로세스가 해제할 수 있으나 뮤텍스는 락을 획득한 프로세스가 그 락을 해제해야 한다.
   ```



## 6. 교착 상태

1. 교착 상태란 무엇인가요? (P.293)

   ```
   - 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태
   ```

2. 교착 상태의 발생 조건에 대해 말해보세요.

   ```
   + 상호배제 : 한 프로세스가 사용하는 자원이 다른 프로세스와 공유할 수 없는 배타적인 자원인 경우
   + 비선점 : 한 프로세스가 사용중에 다른 프로세스가 빼앗을 수 없는 자원
   + 점유와 대기 : 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 경우
   + 원형 대기 : 점유와 대기를 하는 프로세스 간의 관계가 원을 이룸
   ```

3. 교착 상태의 해결 방법을 말하시오. (P.302)

   ```
   - 교착 상태 예방 : 교착 상태를 유발하는 네 가지 조건을 무력화
   - 교착 상태 회피 : 교착 상태가 발생하지 않는 수준으로 자원을 할당
   - 교착 상태 검출 : 자원 할당 그래프를 사용하여 교착 상태를 발견
   - 교착 상태 회복 : 교착 상태를 검출한 후 해결
   ```

4. Banker's algorithm은 무엇입니까? 

   ```
   - Banker's algorithm(은행원 알고리즘)
   - 은행이 대출을 해주는 방식, 즉 대출 금액이 대출 가능한 범위 내이면(안정 상태이면) 허용되지만 그렇지 않으면 거부되는 것과 유사하기 때문에 은행원 알고리즘이라고 불린다.
   ```

5. 상호배제란? 

   ```
   - 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 한다. 배타적인 자원은 임계구역으로 보호되기 때문에 다른 프로세스가 동시에 사용할 수 없다. 따라서 배타적인 자원을 사용하면 교착 상태가 발생한다.
   ```



## 7. 물리 메모리 관리

1. 외부 단편화와 내부 단편화를 비교해보세요. 

   ```
   - 외부 단편화는 가변 분할 방식에서 발생하는 작은 빈공간을 말하고, 내부 단편화는 고정 분할 방식 내부에서 발생하는 작은 빈공간을 의미한다.
   - 외부 단편화를 해결하기 위한 방법으로는 매모리 배치 방식이나 조각 모음이 있고, 내부 단편화는 동일하게 분할되는 공간의 크기를 조절하여 최소화할 수 있다.
   * 매모리 배치 방식 : 작은 조각이 발생하지 않도록 프로세스를 배치
   * 조각 모음 : 조각이 발생했을 때 조각들을 모아서 하나의 큰 덩어리로 만드는 작업
   ```

2. 컴파일러와 인터프리터의 차이점은 무엇인가요? (N사) 

   ```
   - 컴파일러는 소스코드를 전체 기계어로 번역한 후 한꺼번에 실행하는데, 대표적으로 C언어, 자바 등이 이 방식을 이용하고, 인터프리터는 소스코드를 한 행씩 번역하여 실행하고 대표적으로 자바스크립트, 베이직 등이 이 방식을 이용한다.
   + 컴파일러 과정에서 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다.
   + 크고 복잡한 프로그램은 컴파일러, 간단한 프로그램은 인터프리터를 사용하는 것이 좋다.
   ```

3. 메모리 구조가 어떻게 구성되어 있나. (카카오 기출) ✅

   ```
   - 실행할 프로그램의 코드가 저장되어있는 코드영역, 프로그램의 전역 변수와 정적 변수, 문자열 상수가 저장되는 영역인 데이터 영역, 함수의 호출과 관계되는 지역 변수와 매개 변수가 저장되는 영역인 스택 영역, 사용자가 직접 관리할 수 있고 해야만하는 영역인 힙 영역으로 구분되어 있다.
   ```

4. 스왑이 무엇이고 이를 통한 이점은? (카카오 기출) (확실히는 모르겠음...)

   ```
   - 메모리가 모자라서 쫓겨난 프로세스를 모아두는 저장장치의 별도 공간
   - 실제 보유하고 있는 메모리보다 훨씬 많은 양의 메모리를 사용할 수 있다.
   ```

5. 메모리 관리의 배경에 대해 말해보세요.  (잘 모르겠음) ✅ 참고 : 책

   ```
   - 각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.
   
   + 메모리 관리의 복잡성 : 운영체제를 포함한 모든 응용 프로그램이 메모리에 올라와 실행되어 메모리 관리가 복잡함
   + 메모리 관리의 이중성 : 프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 되도록 효율적으로 관리하고 싶어하는 것
   ```

6. 페이징과 세그먼테이션 기법의 차이점을 설명해 보세요. ✅ 가상메모리에만 사용되는걸까?

   ```
   - 페이징은 메모리를 같은 크기로 자르는 것이고 세그먼테이션 기법은 프로세스의 크기에 맞게 자르는 것이다.
   ```

7. 논리적 주소와 물리적 주소의 차이를 설명하시오. ✅ 논리적 주소 = 상대 주소가 같은걸까? 찾아보기

   ```
   - 논리적 주소(상대 주소)는 사용자 프로세스 입장에서 바라본 주소이고, 항상 0부터 시작해서 편리하다. 물리적 주소(절대 주소)는 컴퓨터에 꽂힌 램 메모리의 실제 주소이기 때문에 매번 운영체제 영역을 확인해야하기 때문에 불편하고 실수나 고의적인 조작으로 운영체제 영역을 침범할 수 있는 위험이 있다.
   ```

8. 메모리 오버레이에 대해 알려주세요. 

   ```
   - 프로그램의 크기가 실제 메모리(물리 메모리) 보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법입니다.
   - 프로그램 카운터(PC)가 메모리 오버레이에서 어떤 모듈을 가져오거나 내보낼지 결정합니다.
   
   + 장점 : 한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능하도록 해줌
   ```



## 8. 가상 메모리의 기초

1. 가상 메모리란 무엇인가요?

   ```
   - 물리 메모리(실제 메모리)의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술
   - 현대 메모리 관리의 가장 큰 특징은 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원(=가상메모리)
   ```

2. 페이징은 무엇인가요?

   ```
   - 고정 분할 방식을 이용한 가상 메모리 관리 기법
   
   + 장점 : 물리 메모리를 같은 크기로 나누어 관리해서 관리가 수월함
   + 단점 : 테이블의 크기가 큼
   ```

3. 가상 메모리의 역할은 무엇인가요?

   ```
   - 컴퓨터 내에 있는 하드디스크를 활용해 컴퓨터의 램(RAM)의 능력을 확장시켜 더 많은 프로그램을 구동할 수 있도록 하는 역할을 합니다.
   ```

4. 세그먼테이션 기법이란 무엇인가요?

   ```
   - 가변 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 메모리를 프로세스의 크기에 따라 가변적으로 사용하는 방법입니다.
   + 장점 : 테이블 크기를 작게 유지할 수 있음
   + 단점 : 물리 메모리 외부 단편화로 인해 추가적인 관리 필요
   ```

5. 가상주소공간에 대해 설명하세요. ✅ 가상주소랑 상대주소랑 같은건가요?

   ```
   - 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0번지부터 시작합니다. 가상 주소의 분할된 각 영역은 페이지라고 부릅니다.
   ```



## 9. 가상 메모리 관리

1. 요구 페이징은 무엇인가요? 

   ```
   - 프로세스가 데이터를 요청할 때 메모리로 가져오는 방법
   
   + 용량이 큰 프로세스를 실행할 때 메모리를 효율적으로 관리하고 응답 속도를 향상시키기 위해 프로세스의 일부만 메모리로 가져오는데, 이처럼 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것을 요구 페이징이라 한다.
   ```

2. 페이징 부재(페이지 폴트)는 무엇인지 설명해보세요 

   ```
   - 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황
   
   + 페이지 부재가 발생하면 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 한다.
   ```

3. 페이지 교체 알고리즘 중 LRU에 대해서 설명해 보세요 (N사) 

   ```
   * LRU 페이지 교체 알고리즘 = 최근 최소 사용 페이지 교체 알고리즘
   - 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다.
   - 시간 기준, 카운터, 참조 비트를 이용하여 구현하는 방법이 있다.
   ```

4. 페이지 교체 알고리즘 중 FIFO에 대해서 설명해 보세요 

   ```
   * FIFO 페이지 교체 알고리즘 = 선입선출 페이지 교체 알고리즘
   - 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫓아낸다.
   - 큐로 구현한다.
   - 메모리에 올라온 지 오래되었더라도 자주 사용하는 페이지가 있는데, FIFO 페이지 교체 알고리즘에서는 메모리에 올라온 시간만 고려하기 때문에 자주 사용되는 페이지가 스왑 영역으로 옮겨지기도 함
   ```

5. 페이지 교체 알고리즘 중 LFU에 대해서 설명해 보세요 

   ```
   * LFU 페이지 교체 알고리즘 = 최소 빈도 사용 알고리즘
   - 페이지가 몇 번 사용되었는지를 기준으로 대상 페이지를 선정한다.
   - 현재 프레임에 있는 페이지마다 그동안 사용된 횟수를 세어 횟수가 가장 적은 페이지를 스왑 영역으로 옮긴다.
   - 낭비되는 메모리 공간이 있다.
   ```



## 10. 입출력 시스템과 저장장치

1. RAID란 무엇인가요? 

   ```
   - 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템(레이드)
   ```

2. 디스크 스케줄링 기법이란 무엇이며, 한 가지 스케줄링 기법과 함께 설명하시오. 

   ```
   - 디스크는 저장장치 중에서 자주 사용하지만 탐색 시간이 가장 느리기 때문에 트랙의 이동을 최소화하여 이 탐색 시간을 줄이는데 목적이 있다.
   
   [SCAN 디스크 스케줄링]
   - 헤드가 한 방향으로 움직이면서 맨 마지막 트랙에 도착할 때까지 앞으로만 전진하며 서비스하는 스케줄링 방식
   <장점>
   - 공평성을 덜 위배
   - 성능이 좋음
   <단점>
   - 아사 현상
   - 공평성 완전하게 해결 못함
   
   [LOOK 디스크 스케줄링]
   - SCAN 디스크 스케줄링의 불필요한 탐색 경로를 제거하여 효율을 높인 기법
   <장점>
   - SCAN의 장점 + SCAN 보다 성능이 좋음
   <단점>
   - SCAN의 단점
   ```

3. 인터럽트란? 

   ```
   - 주변장치의 입출력 요구나 하드웨어의 이상 현상을 CPU에 알려주는 역할을 하는 신호이다.
   - 전원 이상이나 기계적 오류 등으로 발생하는 외부 인터럽트와 프로세스의 잘못이나 예상치 못한 문제 때문에 발생하는 인터럽트를 내부 인터럽트라고 부른다.
   ```



## 11. 파일 시스템

1. 순차 파일 구조에 대해 설명해보세요 

   ```
   - 카세트 테이프와 같이 파일 내용이 하나의 긴 줄로 늘어선 형태를 말합니다. 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비가 없지만 파일에 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸립니다.
   
   + 인덱스 파일 구조 / 직접 파일 구조
   ```

2. 디스크 할당 방식 중 연속 할당과 불연속 할당에 대해 설명하시오. 

   ```
   - 연속 할당은 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식이고 불연속 할당은 비어있는 블록에 데이터를 분산하고 저장하여 이에 관한 정보를 파일 시스템이 관리하는 방식입니다.
   
   + 연속 할당은 파일의 시작 블록만 알면 전체 파일을 찾을 수 있다.
   ```



## 12. 네트워크와 분산 시스템

1. 클라이언트/서버 시스템의 구조를 설명해보세요 

   ```
   - 모든 컴퓨터가 동일한 지위를 갖지 않고, 작업을 요청하는 클라이언트와 요청받은 작업을 처리하는 서버의 이중 구조로 되어 있습니다. 서비스 제공자 측에서 서버 관리만 잘해준다면 하드웨어의 비용을 줄일 수 있고, 서비스를 변경하기 위해서는 서버만 바꾸면 된다는 매력적인 장점이 있습니다. 그러나 이러한 중앙집중 방식이 갖는 문제점으로는 서버의 과부하가 있습니다.
   ```

2. 고가용성이란 무엇인가요? ✅ 상시 대기, 상호 인계, 컨커런트 액세스

   ```
   - 클라이언트/서버 시스템은 중앙 서버가 고장이 나면 서비스가 중단됩니다. 이러한 중단을 최소화 하기 위해 이중화 작업을 하는 것을 고가용성이라고 말합니다. 고가용성에는 상시 대기, 상호 인계, 컨커런트 액세스 등으로 구성되어 있습니다. 
   ```
