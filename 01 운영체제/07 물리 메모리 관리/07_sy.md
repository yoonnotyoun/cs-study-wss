# 07 물리 메모리 관리

*<쉽게 배우는 운영체제> pg 374~376*



## 연습문제

1.  인터프리트
2.  소스코드
3.  동적 라이브러리
4. 재배치 
5. 4GB
6. 상대주소
7. 재배치 레지스터
8. 메모리 오버레이
9. 스왑영역
10. 외부 단편화
11. 내부 단편화
12. 최적 배치
13. 최초 배치
14. 최악 배치
15. 조각모음
16. 버디시스템

## 심화문제

1. 컴파일러는 모든코드를 한번에 기계어로 번역하기 때문에 오류발견과 코드의 최적화를 할 수 있다. 한번에 번역하기 때문에 첫 실행시간은 오래걸리지만 이후 반복 실행시에는 빠르다.

   인터프리터는 한줄한줄씩 번역하여 실행하므로 컴파일러처럼 최적화를 하지못한다.

2. 컴파일과정은 소스코드 작성 및 컴파일 > 목적코드와 라이브러리 연결 > 동적 라이브러리를 포함하여 최종 실행 으로 진행된다.
3. 가져오기, 배치, 재배치
4. 절대주소는 메모리관리자 입장에서 바라본 주소로, 실제 물리주소를 말하고
   상대주소는 사용자 프로세스 입장에서 바라본 주소로 절대주소와 관계없이 항상 0부터 시작한다.

5. 가변분할 방식은 프로세스를 자르지 않고 한덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치하기 때문에 좋고, 다만 메모리 관리가 복잡하다는 단점을 가진다.

6. 고정 분할 방식은 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리가 수월하지만 쓸모없는 공간(단편화)이 발생해 메모리가 낭비될 수 있다는 단점을 가진다.
7. 버디 시스템은 가변 분할 방식과 고정 분할 방식의 특징을 모두 가진 것으로(기본적으로는 가변 분할방식), 프로세스를 실행하기 위해 메모리를 분할할 때는 1/2로 나누고, 프로세스가 종료될 때마다 주변을 살펴서 빈 구역을 하나로 합치는 특징을 가진다. 따라서 따로 조각모음을 해줄 필요가 없다.