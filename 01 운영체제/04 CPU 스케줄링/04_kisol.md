**<연습문제>**

1. 고수준
2. 저수준
3. 선점형 스케줄링
4. 전면 프로세스
5. FCFS 스케줄링 (First Come First Served)
6. SJF 스케줄링 (Shortest Job First)
7. 아사 현상
8. - 에이징(Aging) 기법 : 프로세스가 자신의 순서를 양보할 때마다 나이를 먹게 해 특정 나이가 되면 CPU를 배정하도록 하는 기법
   - HRN 스케줄링 : 최고 응답률 우선 스케줄링 기법으로, 우선순위를 정할 때 대기 시간을 고려하는 스케줄링 기법
9.  HRN 스케줄링 (Highest Response Next)
10. 라운드 로빈 스케줄링
11. 타임 슬라이스 크기가 커질 수록 문맥 교환 횟수는 줄어드는 음의 상관관계를 가지고 있다. 타임 슬라이스 크기가 너무 큰 경우, 문맥 교환 횟수가 적어 부가적인 낭비가 적으나 여러 프로그램을 동시에 실행하는 경우 작업 반응 속도가 느리고 끊겨 보이는 현상이 일어날 수 있다. 타임 슬라이스 크기가 너무 작은 경우, 여러 프로그램을 동시에 실행하더라도 반응 속도가 빠르고 끊김 없어 보이나 문맥 교환 횟수가 너무 많아 비효율적이다.

12. SRT 스케줄링 (Shortest Remaining Time)

13. 다단계 큐 스케줄링

14. 다단계 피드백 큐 스케줄링

15. 무한대

16. 우선순위가 낮아질수록 타임 슬라이스의 크기는 더 커짐. 배정받을 기회가 적기 때문에 배정받았을 때 최대한 작업을 진행하기 위해.

17. FCFS 스케줄링

    

**<심화 문제>**

1. 작업 대기 - 보류 프로세스 - 활성 프로세스 - 실행 프로세스 - 작업 종료

   => 고수준 스케줄링 : 작업 대기에서 보류 프로세스로 가는 프로세스의 수를 전체 시스템의 부하를 고려하여 결정

   => 중간 수준 스케줄링 : 보류 프로세스와 활성 프로세스 사이에서 전체 시스템 부하를 고려하여 이미 활성화된 프로세스 중 일부를 보류 상태로 보내거나 여유가 생기면 다시 활성화하는 작업을 함

   => 저수준 스케줄링 : 활성 프로세스와 실행 프로세스 사이에서 프로세스를 선정하여 실행 상태로 옮기거나 타임 아웃으로 준비 상태로 되돌려 보내는 작업을 함

2. - 공평성 : 모든 프로세스가 자원을 공평하게 배정하는 것
   - 효율성 : 시스템 자원이 유휴 시간 없이 사용되어야 하며, 유휴 자원을 사용하려는 프로세스에는 우선권이 주는 것
   - 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정하며, 자원을 점유하거나 파괴하려는 프로세스로부터 보호
   - 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해아하며, 시스템 자원이 늘어나는 경우 반영
   - 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응
   - 무한 연기 방지 : 작업이 무한히 연기되지 않도록 함

3. - 선점형 스케줄링
     - 정의 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
     - 장점 : 빠른 응답 시간 전체 시스템 처리율 높음
     - 단점 : 문맥 교환 같은 부가적인 작업으로 인해 낭비가 생김
     - 사용 : 대부분의 저수준 스케줄러가 현재 사용중 대화형 시스템이나 시분할 시스템에 적합
     - 중요도 : 높음 (선점형과 비선점형 프로세스가 혼재하는 경우 비선점형 프로세스의 중요도를 매우 낮게 설정하여 선점형 프로세스에 영향을 덜 미치도록 함)
   - 비선점형 스케줄링
     - 정의 : 어떤 프로세스가 CPU를 할당받아 실행 중이라면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
     - 장점 : 문맥 교환 같은 부가적인 작업이 적기 때문에 낭비가 적음
     - 단점 : 느린 응답 시간 전체 시스템 처리율 저하 (CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되기 때문)
     - 사용 : 과거 일괄 작업 시스템
     - 중요도 : 낮음
4. - CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간
   - 처리량 : 단위 시간당 작업을 마친 프로세스의 수
   - 대기 시간 : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
   - 응답 시간 : 사용자의 요구에 얼마 만에 반응하는지 측정한 시간 (프로세스 시작 후 첫 번째 출력 혹은 반응이 나올때까지 걸리는 시간)
   - 반환 시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간 (대기 시간 + 실행 시간)
5. - FCFS 스케줄링
     - 준비 큐에 도착한 순서대로  CPU를 할당하는 비선점형 방식
     - 모든 프로세스는 우선순위가 동일
     - 장점 : 단순하고 공평
     - 단점 
       - 처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 계속 기다려 전체 시스템의 효율성이 저하되는 문제 (콘보이 효과/호위 효과)
       - 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어짐
   - SJF 스케줄링
     - 준비 큐에 있는 프로세스 중 실행 시간이 짧은 작업부터 CPU를 할당하는 비선점형 방식
     - 장점 : FCFS 스케줄링의 콘보이 효과 완화하여 평균 대기 시간이 줄어들어 시스템 효율성이 높아짐
     - 단점
       - 어떤 프로세스가 Shortest Job인지 판단하기 어려움 => 프로세스가 자신의 작업 시간을 알려줘 해결 가능하나, 이 또한 정확성이 떨어질 수 있음
       - 공평성 위배하여 아사 현상, 무한 봉쇄 현상 발생 => 에이징 기법을 통해 해결 가능하나, 어떤 기준으로 에이징 값을 정할지 문제
   - HRN 스케줄링
     - 대기 시간과 CPU 사용 시간을 고려하여 우선 순위를 매겨 스케줄링하는 비선점형 방식
     - 장점 : SJF에서 발생할 수 있는 아사 현상 해결
     - 단점 : 여전히 공평성이 위배됨

6. - 라운드 로빈 스케줄링
     - 순환 순서 방식으로, 한 프로세스가 할당받은 타임 슬라이스 동안 작업하다가 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
     - 선점형 알고리즘 중 가장 단순하고 대표적
     - 우선순위가 없음
   - SRT 스케줄링
     - SJF + 라운드 로빈 스케줄링
     - 최소 잔류 시간 우선 스케줄링으로, 기본적으로는 라운드 로빈 형식이지만 CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스 선택
     - 장점 : SJF보다 평균 대기 시간이 짧음
     - 단점
       - 남은 시간을 주기적으로 계산하고 문맥교환이 일어나 SJF에는 없는 부가적인 작업 필요
       - SJF와 마찬가지로 종료시간 예측하기 어려움
       - SJF와 마찬가지로 아사 현상 가능성 있음
   - 다단계 큐 스케줄링
     - 우선순위에 따라 준비 큐를 여러 개 사용하는 방식으로, 상단의 큐(우선순위 높은 큐)에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작됨
     - 장점 : 작업 형태를 고려하여 스케줄링 가능
     - 단점 : 우선순위가 높은 프로세스 때문에 낮은 프로세스의 작업이 연기됨 
   - 다단계 피드백 큐 스케줄링
     - 다단계 큐의 단점을 해결하기 위해 등장한, 우선순위가 낮은 프로세스에 불리함을 보완한 방식
     - CPU를 사용하고 난 프로세스의 우선순위가 낮아지며 원래의 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어감
     - 오늘날 운영체제가 주로 사용
7. - 아사 현상 : 우선순위가 낮은 프로세스의 작업이 계속해서 연기되는 현상
   - 에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식
8. 타임 슬라이스 크기가 너무 큰 경우, 문맥 교환 횟수가 적어 부가적인 낭비가 적으나 여러 프로그램을 동시에 실행하는 경우 작업 반응 속도가 느리고 끊겨 보이는 현상이 일어날 수 있다. 타임 슬라이스 크기가 너무 작은 경우, 여러 프로그램을 동시에 실행하더라도 반응 속도가 빠르고 끊김 없어 보이나 문맥 교환 횟수가 너무 많아 비효율적이다.

